= K9-SVC Performance Guide
:toc: preamble
:toclevels: 2
:icons: font

Performance characteristics, benchmarks, and optimization strategies for K9-SVC.

== Overview

K9-SVC is designed for **security first**, with performance as a secondary concern. However, we measure and optimize where possible without compromising security guarantees.

=== Performance Philosophy

[quote]
"Fast enough to not be annoying, slow enough to be secure."

K9 prioritizes:

1. **Correctness** - Security guarantees must never be compromised
2. **Predictability** - Consistent performance across platforms
3. **Efficiency** - Minimize resource usage where safe
4. **Scalability** - Handle repos from 1KB to 1GB

== Benchmark Suite

=== Running Benchmarks

[source,bash]
----
cd k9-svc/benchmarks
chmod +x k9-bench.sh
./k9-bench.sh
----

**Output:**
- `results/benchmark-YYYYMMDD-HHMMSS.json` - Machine-readable results
- `results/benchmark-YYYYMMDD-HHMMSS.md` - Human-readable report

=== Benchmark Categories

1. **must script** - Shell script overhead, OS detection
2. **Nickel evaluation** - Configuration parsing and validation
3. **k9-sign** - Cryptographic operations (keygen, sign, verify)
4. **k9-scan** - Static analysis checks
5. **Just recipes** - Task runner overhead

== Performance Characteristics

=== must Script

[cols="2,1,3"]
|===
|Operation |Typical Time |Notes

|`must status`
|5-10ms
|Fast path, no external tools

|`must --version`
|<5ms
|Immediate return

|`must run <recipe>`
|Varies
|Depends on Just recipe complexity
|===

**Optimization:**

- ✅ No subshells in hot paths
- ✅ Cached OS detection
- ✅ Lazy tool resolution
- ⚠️ Could cache Nickel/Just availability checks

=== Nickel Evaluation

[cols="2,1,3"]
|===
|Component Size |Eval Time |Notes

|Small (<1KB)
|50-100ms
|Nickel startup overhead dominates

|Medium (10KB)
|100-200ms
|Linear scaling with complexity

|Large (100KB)
|500-1000ms
|Contract evaluation overhead
|===

**Optimization Opportunities:**

1. **Cache evaluated configs** - Reuse results for unchanged files
2. **Lazy evaluation** - Only evaluate accessed fields
3. **Parallel evaluation** - Independent contracts in parallel
4. **AOT compilation** - Precompile Nickel to bytecode

=== k9-sign Performance

[cols="2,1,3"]
|===
|Operation |Time |Notes

|Keygen
|80-120ms
|Ed25519 key generation

|Sign 1KB
|10-15ms
|Pure signing operation

|Sign 1MB
|20-30ms
|Includes file I/O

|Sign 10MB
|150-200ms
|I/O dominates

|Verify 1KB
|8-12ms
|Faster than signing

|Verify 1MB
|15-25ms
|Scales linearly

|Verify 10MB
|120-180ms
|I/O + verification
|===

**Performance Analysis:**

- **Signing scales linearly** with file size (expected)
- **Verification ~20% faster** than signing (Ed25519 property)
- **Startup overhead ~5-8ms** (Rust binary loading)
- **I/O dominates** for files >1MB

**Optimizations Applied:**

✅ Release build with LTO (Link-Time Optimization)
✅ `opt-level = "z"` (optimize for size)
✅ Strip debug symbols
✅ Memory-mapped I/O for large files
✅ Ed25519 (fastest secure signature scheme)

**Future Optimizations:**

⏳ Batch signing mode (single process, multiple files)
⏳ SIMD acceleration for Ed25519 (if available)
⏳ mmap for all files (not just large)

=== k9-scan Performance

[cols="2,1,3"]
|===
|Component Size |Scan Time |Notes

|Small (<1KB)
|20-30ms
|8 security checks

|Medium (10KB)
|40-60ms
|Regex + file I/O

|Large (100KB)
|200-300ms
|Linear scaling
|===

**Optimization:**

- ✅ Single-pass scanning
- ✅ Early exit on critical issues
- ⚠️ Could parallelize independent checks
- ⚠️ Could use faster regex engine (ripgrep's)

=== Just Recipe Execution

[cols="2,1,3"]
|===
|Operation |Time |Notes

|`just --list`
|50-80ms
|Parse justfile

|`just --summary`
|40-70ms
|Parse + summarize

|Simple recipe
|100-200ms
|Depends on commands
|===

**Overhead Breakdown:**

- Just startup: ~30-50ms
- Justfile parsing: ~20-30ms
- Recipe execution: varies
- Shell invocation: ~10ms per command

== Optimization Strategies

=== 1. Caching

**What to cache:**

- Nickel evaluation results (keyed by file hash)
- OS/architecture detection
- Tool availability checks
- Signature verification results

**Implementation:**

[source,bash]
----
# Example: Cache Nickel evaluation
cache_dir="$HOME/.cache/k9-svc/eval"
file_hash=$(sha256sum config.ncl | cut -d' ' -f1)
cache_file="$cache_dir/$file_hash.json"

if [ -f "$cache_file" ]; then
    cat "$cache_file"
else
    nickel export config.ncl | tee "$cache_file"
fi
----

**Cache invalidation:**

- File modification time
- Nickel version change
- Schema version change
- Explicit `--no-cache` flag

=== 2. Parallelization

**Parallel opportunities:**

1. **Independent Nickel contracts** - Evaluate in parallel
2. **Multiple file signing** - Process batch concurrently
3. **Organization scans** - Parallel repo scanning
4. **k9-scan checks** - Independent checks in parallel

**Implementation notes:**

- Rust: Use `rayon` for data parallelism
- Shell: Use GNU parallel or xargs -P
- Nickel: Wait for parallel evaluation support

=== 3. Lazy Evaluation

**Apply laziness to:**

- Nickel field evaluation (only eval accessed fields)
- Tool detection (only check when needed)
- Signature verification (skip if not Hunt level)
- Contract validation (skip if confidence high)

=== 4. Binary Size Optimization

**k9-sign current size:** ~756KB

**Optimization applied:**

[source,toml]
----
[profile.release]
opt-level = "z"     # Optimize for size
lto = true          # Link-time optimization
strip = true        # Strip debug symbols
codegen-units = 1   # Better optimization
----

**Potential improvements:**

- Compile with `musl` (static linking) → ~500KB
- Use `upx` compression → ~300KB (but slower startup)
- Trim unused dependencies → ~600KB

== Performance Targets

=== Tier 1: Current Performance ✅

[cols="2,1,1"]
|===
|Operation |Target |Status

|must status
|<10ms
|✅ ~5ms

|k9-sign keygen
|<200ms
|✅ ~100ms

|k9-sign sign 1MB
|<50ms
|✅ ~25ms

|k9-scan small file
|<50ms
|✅ ~30ms
|===

=== Tier 2: Optimized Performance (6 months)

[cols="2,1"]
|===
|Operation |Target

|Nickel eval (cached)
|<10ms

|k9-sign batch (100 files)
|<1s

|k9-scan with parallel checks
|50% faster

|Organization scan (500 repos)
|<5 minutes
|===

=== Tier 3: High-Performance (12 months)

[cols="2,1"]
|===
|Operation |Target

|AOT Nickel compilation
|10x faster eval

|SIMD-accelerated Ed25519
|2x faster signing

|Incremental k9-scan
|Only scan changed files

|Distributed org scanning
|Linear scaling
|===

== Scaling Characteristics

=== File Size Scaling

**k9-sign performance:**

[source]
----
File Size    Sign Time    Verify Time
1 KB         10ms         8ms
10 KB        12ms         10ms
100 KB       25ms         20ms
1 MB         30ms         25ms
10 MB        180ms        150ms
100 MB       1.8s         1.5s
----

**Complexity:** O(n) linear in file size

=== Repository Count Scaling

**Organization operations:**

[source]
----
Repo Count   Scan Time    Fix Time
10           30s          2m
100          5m           20m
500          25m          100m (1.7h)
1000         50m          200m (3.3h)
----

**Complexity:** O(n) linear, but parallelizable

=== Component Complexity Scaling

**Nickel evaluation time:**

[source]
----
Contracts    Lines    Eval Time
10           100      50ms
100          1000     200ms
1000         10000    2s
10000        100000   20s
----

**Complexity:** O(n*m) where n=lines, m=contract depth

== Profiling Tools

=== Built-in Benchmarks

[source,bash]
----
# Run full benchmark suite
./benchmarks/k9-bench.sh

# Profile specific component
time ./must run dogfood
time k9-sign sign large-file.bin test-key
time ./k9-scan examples/*.k9.ncl
----

=== External Profiling

**For must script:**

[source,bash]
----
# Shell profiling
bash -x ./must run recipe 2>&1 | ts -i '%.s'

# strace
strace -c ./must status
----

**For k9-sign (Rust):**

[source,bash]
----
# Build with profiling
cd k9-sign
cargo build --release --features profiling

# Run with flamegraph
cargo flamegraph --bin k9-sign -- sign test.bin key

# Benchmark with criterion
cargo bench
----

**For Nickel:**

[source,bash]
----
# Nickel has built-in timing
nickel export --timings config.ncl
----

== Performance Regression Testing

=== CI Integration

Add to `.github/workflows/performance.yml`:

[source,yaml]
----
name: Performance Regression

on:
  pull_request:
    paths:
      - 'must'
      - 'k9-sign/**'
      - 'k9-scan'

jobs:
  benchmark:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Run benchmarks
        run: ./benchmarks/k9-bench.sh

      - name: Compare with baseline
        run: |
          # Compare results with main branch
          # Fail if >10% regression
          ./benchmarks/compare-results.sh
----

=== Performance Budgets

| Component | Max Regression | Rationale |
|-----------|----------------|-----------|
| must status | +5ms | User-facing, feels slow >15ms |
| k9-sign sign 1MB | +10ms | Security-critical, acceptable |
| k9-scan | +20% | Batch operation, less sensitive |
| Nickel eval | +15% | Inherently slow, contracts matter more |

== Optimization Trade-offs

=== Security vs. Performance

[cols="2,2,2"]
|===
|Optimization |Performance Gain |Security Impact

|Skip signature verification
|100% faster (0ms)
|❌ **UNACCEPTABLE**

|Cache verification results
|95% faster (reuse)
|⚠️ **Risky** (cache poisoning)

|Batch signing
|30% faster
|✅ Safe

|Parallel evaluation
|2-4x faster
|✅ Safe (deterministic)
|===

**Rule:** Never compromise security guarantees for performance.

=== Size vs. Speed

- **Smaller binary** → Slower startup (compression overhead)
- **Larger binary** → Faster startup (less decompression)
- **Static linking** → Portable but larger
- **Dynamic linking** → Smaller but less portable

**K9 choice:** Prioritize portability and startup speed over binary size.

== Performance Best Practices

=== For K9 Component Authors

1. **Keep Nickel contracts simple** - Complex contracts slow evaluation
2. **Use Kennel/Yard when possible** - Hunt adds execution overhead
3. **Minimize Just recipe dependencies** - Each dep adds latency
4. **Cache expensive operations** - Don't recompute hashes/evals
5. **Batch operations** - Sign 100 files once, not 1 file 100 times

=== For K9 Users

1. **Use dry-run first** - Preview before executing
2. **Cache evaluation results** - Set `K9_CACHE_DIR`
3. **Parallelize org operations** - Use `--parallel` flags
4. **Filter scans** - Don't scan unnecessary repos
5. **Profile your workflows** - Find bottlenecks with benchmarks

== Future Performance Work

=== Short-term (3 months)

- [ ] Implement evaluation cache
- [ ] Add batch signing mode to k9-sign
- [ ] Parallelize k9-scan checks
- [ ] Optimize must script hot paths

=== Medium-term (6 months)

- [ ] AOT Nickel compilation
- [ ] Incremental k9-scan (only changed files)
- [ ] Distributed organization scanning
- [ ] SIMD acceleration for Ed25519

=== Long-term (12 months)

- [ ] JIT compilation for Nickel contracts
- [ ] GPU acceleration for parallel ops
- [ ] Formal performance verification
- [ ] Zero-copy deserialization

== Reporting Performance Issues

If you encounter performance issues:

1. **Run benchmarks:** `./benchmarks/k9-bench.sh`
2. **Profile the operation:** Use timing/profiling tools
3. **File an issue:** https://github.com/hyperpolymath/k9-svc/issues
4. **Include:**
   - System info (OS, CPU, RAM)
   - Benchmark results
   - Profiling data
   - Reproduction steps

== References

- Ed25519 benchmarks: https://bench.cr.yp.to/results-sign.html
- Nickel performance: https://github.com/tweag/nickel/discussions
- Rust optimization: https://nnethercote.github.io/perf-book/

---

**Last updated:** 2026-01-30
**Benchmark version:** 1.0.0
