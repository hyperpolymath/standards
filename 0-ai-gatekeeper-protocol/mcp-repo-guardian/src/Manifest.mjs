// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Nodepath from "node:path";
import * as Belt_Option from "@rescript/runtime/lib/es6/Belt_Option.js";
import * as Nodecrypto from "node:crypto";
import * as Stdlib_JsError from "@rescript/runtime/lib/es6/Stdlib_JsError.js";
import * as Primitive_option from "@rescript/runtime/lib/es6/Primitive_option.js";
import * as Promises from "node:fs/promises";

function extractCanonicalLocations(content) {
  let scmMatch = /SCM files.*?`([^`]+)`/i.exec(content);
  let botMatch = /Bot [Dd]irectives.*?`([^`]+)`/i.exec(content);
  let scmFiles;
  if (scmMatch == null) {
    scmFiles = ".machine_readable/";
  } else {
    let matches = scmMatch.slice(1);
    let v = matches[1];
    scmFiles = v !== undefined ? Belt_Option.getWithDefault(Primitive_option.valFromOption(v), ".machine_readable/") : ".machine_readable/";
  }
  let botDirectives;
  if (botMatch == null) {
    botDirectives = ".bot_directives/";
  } else {
    let matches$1 = botMatch.slice(1);
    let v$1 = matches$1[1];
    botDirectives = v$1 !== undefined ? Belt_Option.getWithDefault(Primitive_option.valFromOption(v$1), ".bot_directives/") : ".bot_directives/";
  }
  let agentInstructions = [
    ".claude/CLAUDE.md",
    "AI.a2ml",
    "0-AI-MANIFEST.a2ml"
  ];
  return {
    scmFiles: scmFiles,
    botDirectives: botDirectives,
    agentInstructions: agentInstructions
  };
}

function extractInvariants(content) {
  let invariants = [];
  if (Belt_Option.isSome(Primitive_option.fromNullable(content.match(/No SCM file duplication/i)))) {
    invariants.push("no_scm_duplication");
  }
  if (Belt_Option.isSome(Primitive_option.fromNullable(content.match(/Single source of truth/i)))) {
    invariants.push("single_source_of_truth");
  }
  if (Belt_Option.isSome(Primitive_option.fromNullable(content.match(/No stale metadata/i)))) {
    invariants.push("no_stale_metadata");
  }
  return invariants;
}

async function parseManifest(repoPath) {
  let manifestNames = [
    "0-AI-MANIFEST.a2ml",
    "AI.a2ml",
    "!AI.a2ml"
  ];
  let tryReadManifest = async (names, index) => {
    if (index >= names.length) {
      return;
    }
    let name = names[index];
    if (name === undefined) {
      return await tryReadManifest(names, index + 1 | 0);
    }
    let path = Nodepath.join(repoPath, name);
    try {
      let content = await Promises.readFile(path, "utf-8");
      return [
        content,
        path
      ];
    } catch (exn) {
      return await tryReadManifest(names, index + 1 | 0);
    }
  };
  let result = await tryReadManifest(manifestNames, 0);
  if (result === undefined) {
    return Stdlib_JsError.throwWithMessage(`No AI manifest found in ` + repoPath + `. Expected one of: ` + manifestNames.join(", "));
  }
  let manifestContent = result[0];
  let hashObj = Nodecrypto.createHash("sha256");
  let hash = hashObj.update(manifestContent).digest("hex");
  let canonicalLocations = extractCanonicalLocations(manifestContent);
  let invariants = extractInvariants(manifestContent);
  return {
    hash: hash,
    canonicalLocations: canonicalLocations,
    invariants: invariants,
    parsedAt: new Date()
  };
}

function validateAttestation(manifest, providedHash) {
  return manifest.hash === providedHash;
}

export {
  extractCanonicalLocations,
  extractInvariants,
  parseManifest,
  validateAttestation,
}
/* node:path Not a pure module */
