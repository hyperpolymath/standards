// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Belt_Option from "@rescript/runtime/lib/es6/Belt_Option.js";
import * as Stdlib_JsError from "@rescript/runtime/lib/es6/Stdlib_JsError.js";
import * as Session$HyperpolymathMcpRepoGuardian from "./Session.mjs";

function make(sessionManager, manifest) {
  return {
    sessionManager: sessionManager,
    manifest: manifest
  };
}

function checkAccess(guard, sessionId) {
  let session = Session$HyperpolymathMcpRepoGuardian.SessionManager.getSession(guard.sessionManager, sessionId);
  if (session === undefined) {
    return {
      allowed: false,
      reason: "Invalid session ID. Session may have expired."
    };
  }
  if (session.acknowledgedManifest) {
    return {
      allowed: true,
      reason: undefined
    };
  }
  let hashPreview = guard.manifest.hash.substring(0, 16);
  return {
    allowed: false,
    reason: "⚠️ ACCESS DENIED\n\nYou must read and acknowledge the AI manifest (AI.a2ml) before accessing any files in this repository.\n\nCall the acknowledge_manifest tool with the manifest hash to proceed.\n\n" + (`Expected hash: ` + hashPreview + `...`)
  };
}

function validatePath(guard, path) {
  if (!guard.manifest.invariants.includes("no_scm_duplication")) {
    return {
      allowed: true,
      reason: undefined
    };
  }
  let scmFiles = [
    "STATE.scm",
    "META.scm",
    "ECOSYSTEM.scm",
    "AGENTIC.scm",
    "NEUROSYM.scm",
    "PLAYBOOK.scm",
    "LANGUAGES.scm"
  ];
  let isViolation = scmFiles.some(scmFile => {
    if (path.endsWith(scmFile)) {
      return !path.includes(".machine_readable/");
    } else {
      return false;
    }
  });
  if (!isViolation) {
    return {
      allowed: true,
      reason: undefined
    };
  }
  let violatedFile = Belt_Option.getWithDefault(scmFiles.find(scmFile => path.endsWith(scmFile)), "unknown");
  return {
    allowed: false,
    reason: "⚠️ INVARIANT VIOLATION\n\n" + (`Attempted to access ` + violatedFile + ` outside of .machine_readable/ directory.\n\n`) + "Per AI.a2ml manifest: SCM files MUST be in .machine_readable/ only.\nThis prevents duplicate file errors."
  };
}

function requireAcknowledgment(guard, sessionId, operation) {
  let access = checkAccess(guard, sessionId);
  if (access.allowed) {
    return;
  }
  let reason = Belt_Option.getWithDefault(access.reason, "Unknown reason");
  Stdlib_JsError.throwWithMessage(`Cannot perform ` + operation + `: ` + reason);
}

let AccessGuard = {
  make: make,
  checkAccess: checkAccess,
  validatePath: validatePath,
  requireAcknowledgment: requireAcknowledgment
};

export {
  AccessGuard,
}
/* Session-HyperpolymathMcpRepoGuardian Not a pure module */
