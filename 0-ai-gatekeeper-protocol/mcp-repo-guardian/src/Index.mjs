// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Belt_Int from "@rescript/runtime/lib/es6/Belt_Int.js";
import * as Nodepath from "node:path";
import * as Belt_Option from "@rescript/runtime/lib/es6/Belt_Option.js";
import * as Stdlib_JSON from "@rescript/runtime/lib/es6/Stdlib_JSON.js";
import * as Promises from "node:fs/promises";
import * as Guards$HyperpolymathMcpRepoGuardian from "./Guards.mjs";
import * as Session$HyperpolymathMcpRepoGuardian from "./Session.mjs";
import * as Manifest$HyperpolymathMcpRepoGuardian from "./Manifest.mjs";
import * as IndexJs from "@modelcontextprotocol/sdk/server/index.js";
import * as StdioJs from "@modelcontextprotocol/sdk/server/stdio.js";

let MCP = {};

function getEnv(name, $$default) {
  let env = process.env;
  let v = env[name];
  if (v !== undefined) {
    return v;
  } else {
    return $$default;
  }
}

function make() {
  let cwd = (() => process.cwd());
  let config_basePath = getEnv("REPOS_PATH", cwd());
  let config_strictMode = getEnv("STRICT_MODE", "false") === "true";
  let config_sessionTimeout = Belt_Option.getWithDefault(Belt_Int.fromString(getEnv("SESSION_TIMEOUT", "3600000")), 3600000);
  let config = {
    basePath: config_basePath,
    strictMode: config_strictMode,
    sessionTimeout: config_sessionTimeout
  };
  let server = new IndexJs.Server({
    name: "repo-guardian",
    version: "0.1.0"
  });
  let sessionManager = Session$HyperpolymathMcpRepoGuardian.SessionManager.make(config);
  return {
    server: server,
    config: config,
    sessionManager: sessionManager,
    manifests: {}
  };
}

async function handleGetManifest(guardian, repoPath) {
  let fullPath = Nodepath.resolve(guardian.config.basePath, repoPath);
  let manifest = await Manifest$HyperpolymathMcpRepoGuardian.parseManifest(fullPath);
  guardian.manifests[repoPath] = manifest;
  let content = [Object.fromEntries([
      [
        "type",
        "text"
      ],
      [
        "text",
        `Manifest hash: ` + manifest.hash + `\n\nYou must acknowledge this manifest with the hash to proceed.`
      ]
    ])];
  return {
    content: content
  };
}

async function handleAcknowledgeManifest(guardian, repoPath, attestationHash) {
  let manifest = guardian.manifests[repoPath];
  if (manifest !== undefined) {
    if (Manifest$HyperpolymathMcpRepoGuardian.validateAttestation(manifest, attestationHash)) {
      let session = Session$HyperpolymathMcpRepoGuardian.SessionManager.createSession(guardian.sessionManager, repoPath);
      Session$HyperpolymathMcpRepoGuardian.SessionManager.acknowledgeManifest(guardian.sessionManager, session.sessionId, manifest, attestationHash);
      let content = [Object.fromEntries([
          [
            "type",
            "text"
          ],
          [
            "text",
            `âœ… Manifest acknowledged! Session ID: ` + session.sessionId
          ]
        ])];
      return {
        content: content
      };
    }
    let content$1 = [Object.fromEntries([
        [
          "type",
          "text"
        ],
        [
          "text",
          "ERROR: Invalid attestation hash"
        ]
      ])];
    return {
      content: content$1
    };
  }
  let content$2 = [Object.fromEntries([
      [
        "type",
        "text"
      ],
      [
        "text",
        "ERROR: You must call get_manifest first"
      ]
    ])];
  return {
    content: content$2
  };
}

async function handleReadFile(guardian, sessionId, path) {
  let session = Session$HyperpolymathMcpRepoGuardian.SessionManager.getSession(guardian.sessionManager, sessionId);
  if (session !== undefined) {
    let manifest = guardian.manifests[session.repoPath];
    if (manifest !== undefined) {
      let accessGuard = Guards$HyperpolymathMcpRepoGuardian.AccessGuard.make(guardian.sessionManager, manifest);
      let accessResult = Guards$HyperpolymathMcpRepoGuardian.AccessGuard.checkAccess(accessGuard, sessionId);
      if (accessResult.allowed) {
        let pathResult = Guards$HyperpolymathMcpRepoGuardian.AccessGuard.validatePath(accessGuard, path);
        if (pathResult.allowed) {
          let fullPath = Nodepath.join(guardian.config.basePath, Nodepath.join(session.repoPath, path));
          try {
            let fileContent = await Promises.readFile(fullPath, "utf-8");
            let content = [Object.fromEntries([
                [
                  "type",
                  "text"
                ],
                [
                  "text",
                  fileContent
                ]
              ])];
            return {
              content: content
            };
          } catch (exn) {
            let content$1 = [Object.fromEntries([
                [
                  "type",
                  "text"
                ],
                [
                  "text",
                  `ERROR: Failed to read file ` + path
                ]
              ])];
            return {
              content: content$1
            };
          }
        } else {
          let reason = Belt_Option.getWithDefault(pathResult.reason, "Unknown");
          let content$2 = [Object.fromEntries([
              [
                "type",
                "text"
              ],
              [
                "text",
                `ERROR: ` + reason
              ]
            ])];
          return {
            content: content$2
          };
        }
      } else {
        let reason$1 = Belt_Option.getWithDefault(accessResult.reason, "Unknown");
        let content$3 = [Object.fromEntries([
            [
              "type",
              "text"
            ],
            [
              "text",
              `ERROR: ` + reason$1
            ]
          ])];
        return {
          content: content$3
        };
      }
    } else {
      let content$4 = [Object.fromEntries([
          [
            "type",
            "text"
          ],
          [
            "text",
            "ERROR: Manifest not found"
          ]
        ])];
      return {
        content: content$4
      };
    }
  } else {
    let content$5 = [Object.fromEntries([
        [
          "type",
          "text"
        ],
        [
          "text",
          "ERROR: Invalid session ID"
        ]
      ])];
    return {
      content: content$5
    };
  }
}

async function start(guardian) {
  guardian.server.setRequestHandler("tools/list", async _request => {
    let content = [];
    return {
      content: content
    };
  });
  guardian.server.setRequestHandler("tools/call", async request => {
    let name = request.name;
    let args = request.arguments;
    switch (name) {
      case "acknowledge_manifest" :
        let repoPath = Belt_Option.getWithDefault(Belt_Option.flatMap(args["repoPath"], Stdlib_JSON.Decode.string), "");
        let attestationHash = Belt_Option.getWithDefault(Belt_Option.flatMap(args["attestationHash"], Stdlib_JSON.Decode.string), "");
        return await handleAcknowledgeManifest(guardian, repoPath, attestationHash);
      case "get_manifest" :
        let repoPath$1 = Belt_Option.getWithDefault(Belt_Option.flatMap(args["repoPath"], Stdlib_JSON.Decode.string), "");
        return await handleGetManifest(guardian, repoPath$1);
      case "read_file" :
        let sessionId = Belt_Option.getWithDefault(Belt_Option.flatMap(args["sessionId"], Stdlib_JSON.Decode.string), "");
        let path = Belt_Option.getWithDefault(Belt_Option.flatMap(args["path"], Stdlib_JSON.Decode.string), "");
        return await handleReadFile(guardian, sessionId, path);
      default:
        let content = [Object.fromEntries([
            [
              "type",
              "text"
            ],
            [
              "text",
              `Unknown tool: ` + name
            ]
          ])];
        return {
          content: content
        };
    }
  });
  let transport = new StdioJs.StdioServerTransport();
  await guardian.server.connect(transport);
  console.log("MCP Repository Guardian started");
}

let GuardianServer = {
  make: make,
  handleGetManifest: handleGetManifest,
  handleAcknowledgeManifest: handleAcknowledgeManifest,
  handleReadFile: handleReadFile,
  start: start
};

async function main() {
  let guardian = make();
  return await start(guardian);
}

main();

export {
  MCP,
  getEnv,
  GuardianServer,
  main,
}
/*  Not a pure module */
