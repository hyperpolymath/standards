= META Format Specification
:doctype: book
:toc: left
:toclevels: 4
:sectnums:
:source-highlighter: highlight.js
:icons: font

[.text-center]
*Internet-Draft Style Specification* +
*Version 1.0.0-draft.1* +
*December 2025*

== Abstract

This document specifies the META (Machine-readable Engineering and Technical
Architecture) file format, a Scheme-based syntax for encoding project metadata,
architecture decisions, and development practices in a format that is both
machine-parseable and human-readable. META files provide a standardized way to
document software project governance, architectural decisions (ADRs), coding
standards, and design rationale.

== Status of This Memo

This document specifies an experimental protocol for the Internet community.
This is a contribution to the RFC series, independently of any other RFC stream.
Discussion and suggestions for improvement are requested.

Distribution of this memo is unlimited.

== Copyright Notice

Copyright (c) 2025 Jonathan D.A. Jewell. MIT License.

This document is subject to the provisions of the MIT License.


== Introduction

=== Purpose

META.scm files address the need for machine-readable project documentation that:

1. **Captures Architecture Decisions** - Records ADRs in a structured format
2. **Documents Development Practices** - Codifies coding standards and workflows
3. **Preserves Design Rationale** - Explains the "why" behind technical choices
4. **Enables Tooling** - Allows automated analysis and enforcement

=== Design Goals

Declarative Format::
  Pure data structures without executable code in standard sections

Human Readable::
  S-expression syntax is readable without special tooling

Machine Parseable::
  Well-defined grammar enables automated processing

Extensible::
  Custom sections can be added without breaking compatibility

VCS Friendly::
  Text-based format works well with version control systems

=== Relationship to Other Specifications

[cols="1,3"]
|===
|Specification |Relationship

|R7RS Scheme
|META uses Scheme syntax but is a data format, not executable code

|MADR (Markdown ADR)
|META provides similar ADR functionality in structured form

|RFC 5234 (ABNF)
|META grammar is formally specified in ABNF

|SPDX
|META may reference SPDX license identifiers

|SemVer 2.0.0
|Version numbers follow Semantic Versioning
|===


== Terminology

=== Key Words

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD",
"SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this
document are to be interpreted as described in BCP 14 (RFC 2119, RFC 8174).

=== Definitions

META File::
  A file with `.scm` extension (typically `META.scm`) containing project
  metadata in the format specified by this document.

Section::
  A top-level `define` expression that declares a named data structure.

Core Section::
  A section with standardized semantics defined by this specification.

Extension Section::
  A project-specific section not defined by this specification.

ADR (Architecture Decision Record)::
  A structured record documenting an architectural decision.

Association List (alist)::
  A list of key-value pairs in the form `((key . value) ...)`.


== File Structure

=== Overview

A META file consists of:

1. **Header Comments** - License and file description
2. **Module Declaration** - Scheme module definition
3. **Section Definitions** - One or more `define` expressions

=== ABNF Grammar Reference

The complete formal grammar is provided in `abnf/meta.abnf`. This section
provides a normative summary.

=== Header Comments

META files SHOULD begin with SPDX license headers:

[source,scheme]
----
;; SPDX-License-Identifier: PMPL-1.0-or-later
;; SPDX-FileCopyrightText: 2025 Example Author
----

Documentation comments use triple semicolons:

[source,scheme]
----
;;; META.scm — Architecture Decisions and Development Practices
;;; project-name
----

=== Module Declaration

META files MUST contain exactly one module declaration:

[source,scheme]
----
(define-module (project-name meta)
  #:export (architecture-decisions
            development-practices
            design-rationale))
----

Requirements:

* Module path SHOULD follow the pattern `(project-name meta)`
* Exports SHOULD list all public section names
* Additional directives MAY be included

=== Section Definitions

Each section is a top-level `define` expression:

[source,scheme]
----
(define section-name
  'section-data)
----


== Core Sections

=== Architecture Decisions (`architecture-decisions`)

==== Purpose

Records architecture decisions in a structured format following ADR principles.

==== Structure

[source,scheme]
----
(define architecture-decisions
  '((adr-NNN
     (title . "Decision Title")
     (status . "accepted")
     (date . "YYYY-MM-DD")
     (context . "Problem description")
     (decision . "What was decided")
     (consequences . ("Consequence 1" "Consequence 2")))
    ...))
----

==== Field Definitions

[cols="1,1,3"]
|===
|Field |Required |Description

|`title`
|REQUIRED
|Short descriptive title (string)

|`status`
|REQUIRED
|Current status (see <<adr-status-values>>)

|`date`
|REQUIRED
|Date of decision in ISO 8601 format (YYYY-MM-DD)

|`context`
|REQUIRED
|Problem or situation that prompted the decision (string)

|`decision`
|REQUIRED
|What was decided (string)

|`consequences`
|RECOMMENDED
|List of resulting implications (list of strings)

|`supersedes`
|OPTIONAL
|ADR ID(s) this decision supersedes (symbol or list)

|`superseded-by`
|OPTIONAL
|ADR ID that supersedes this one (symbol)

|`deciders`
|OPTIONAL
|People involved in the decision (list of strings)

|`references`
|OPTIONAL
|Related URLs or documents (list of strings)
|===

[[adr-status-values]]
==== Status Values

[cols="1,3"]
|===
|Status |Meaning

|`proposed`
|Under consideration, not yet decided

|`accepted`
|Decision made and in effect

|`deprecated`
|No longer recommended, kept for historical reference

|`superseded`
|Replaced by another decision (use `superseded-by` field)

|`rejected`
|Considered but not adopted
|===

==== ADR Numbering

ADR identifiers SHOULD follow the pattern `adr-NNN` where:

* `adr-` is the literal prefix
* `NNN` is a zero-padded sequential number (e.g., `001`, `002`)

Numbers SHOULD be assigned sequentially and MUST NOT be reused.

==== Example

[source,scheme]
----
(define architecture-decisions
  '((adr-001
     (title . "Use PostgreSQL for Primary Database")
     (status . "accepted")
     (date . "2025-01-15")
     (context . "Need a relational database that supports JSON,
                 full-text search, and strong consistency")
     (decision . "Use PostgreSQL 16+ as the primary database")
     (consequences . ("Excellent JSON support via JSONB"
                      "Built-in full-text search"
                      "Requires operational expertise"
                      "Single-node by default, extensions for HA")))

    (adr-002
     (title . "Adopt Event Sourcing for Order Service")
     (status . "accepted")
     (date . "2025-02-01")
     (context . "Order history and audit trail requirements")
     (decision . "Implement event sourcing pattern for orders")
     (consequences . ("Complete audit trail"
                      "Temporal queries supported"
                      "Increased storage requirements"
                      "Eventual consistency considerations")))))
----


=== Development Practices (`development-practices`)

==== Purpose

Codifies development standards, workflows, and tooling requirements.

==== Structure

[source,scheme]
----
(define development-practices
  '((category
     (setting . "value")
     (setting . "value"))
    ...))
----

==== Standard Categories

[cols="1,3"]
|===
|Category |Purpose

|`code-style`
|Formatting, linting, and style guidelines

|`security`
|Security requirements and practices

|`documentation`
|Documentation format and requirements

|`testing`
|Testing strategy and requirements

|`versioning`
|Version numbering and changelog practices

|`deployment`
|Deployment procedures and environments

|`review`
|Code review process and requirements

|`branching`
|Git branching strategy
|===

==== Common Fields by Category

===== `code-style`

[source,scheme]
----
(code-style
  (formatter . "prettier")
  (linter . "eslint")
  (type-system . "TypeScript")
  (line-length . 100)
  (indent . "spaces")
  (indent-size . 2))
----

===== `security`

[source,scheme]
----
(security
  (command-execution . "subprocess only, never shell")
  (input-validation . "whitelist + schema validation")
  (credentials . "env vars or secrets manager")
  (dependencies . "audit weekly, update monthly"))
----

===== `testing`

[source,scheme]
----
(testing
  (framework . "jest")
  (coverage-minimum . 80)
  (unit-tests . "required for all business logic")
  (integration-tests . "required for API endpoints")
  (e2e-tests . "smoke tests for critical paths"))
----

===== `versioning`

[source,scheme]
----
(versioning
  (scheme . "Semantic Versioning 2.0.0")
  (changelog . "Keep a Changelog format")
  (release-process . "GitHub releases with auto-generated notes"))
----

==== Example

[source,scheme]
----
(define development-practices
  '((code-style
     (formatter . "deno fmt")
     (linter . "deno lint")
     (type-system . "TypeScript strict mode"))

    (security
     (command-execution . "Deno.Command only, never shell")
     (input-validation . "Zod schemas at boundaries")
     (credentials . "Environment variables only"))

    (documentation
     (format . "AsciiDoc")
     (api-docs . "OpenAPI 3.1")
     (adr-location . "META.scm"))

    (testing
     (framework . "Deno.test")
     (coverage-minimum . 70)
     (mutation-testing . "planned"))

    (versioning
     (scheme . "Semantic Versioning 2.0.0")
     (changelog . "Keep a Changelog format"))))
----


=== Design Rationale (`design-rationale`)

==== Purpose

Documents the reasoning behind major design decisions in narrative form.

==== Structure

[source,scheme]
----
(define design-rationale
  '((topic-key
     "Explanatory text describing the rationale...")
    ...))
----

==== Guidelines

* Topics SHOULD use descriptive kebab-case symbols (e.g., `why-chose-rust`)
* Text SHOULD explain the "why" not just the "what"
* Multiple paragraphs MAY be included as a single multi-line string
* References to ADRs SHOULD use the ADR ID

==== Example

[source,scheme]
----
(define design-rationale
  '((why-event-sourcing
     "Event sourcing was chosen over traditional CRUD for the order
      service because of strict audit requirements and the need to
      reconstruct order state at any point in time. See adr-002 for
      the formal decision record.")

    (why-postgresql
     "PostgreSQL provides the best combination of relational integrity,
      JSON support for semi-structured data, and full-text search
      without requiring additional infrastructure. The team has
      existing PostgreSQL expertise, reducing operational risk.")

    (why-not-microservices
     "Despite industry trends, we chose a modular monolith because:
      (1) team size doesn't justify distribution overhead,
      (2) strong consistency requirements across domains,
      (3) simpler deployment and debugging.
      This decision will be revisited when the team exceeds 20 engineers.")))
----


== Extension Sections

=== Defining Extensions

Projects MAY define additional sections beyond the core three. Extensions
MUST follow these rules:

1. Use unique symbol names that don't conflict with core sections
2. Follow the same `(define name 'data)` structure
3. Document the schema in project documentation
4. Consider proposing widely-useful extensions for standardization

=== Reserved Names

The following names are RESERVED for future standardization:

* `dependencies`
* `build-configuration`
* `deployment-targets`
* `team-structure`
* `api-contracts`
* `data-schemas`
* `compliance-requirements`

=== Extension Example

[source,scheme]
----
;;; Project-specific extension
(define compliance-requirements
  '((gdpr
     (data-retention . "2 years")
     (pii-encryption . "AES-256-GCM")
     (right-to-erasure . "automated via user portal"))

    (sox
     (audit-logging . "immutable event log")
     (access-controls . "RBAC with quarterly review"))))
----


== Data Types

=== Primitive Types

[cols="1,2,2"]
|===
|Type |Syntax |Example

|String
|Double-quoted text
|`"Hello, world"`

|Symbol
|Unquoted identifier
|`my-symbol`

|Integer
|Decimal digits with optional sign
|`42`, `-17`

|Decimal
|Digits with decimal point
|`3.14`, `-0.5`

|Boolean
|`#t` or `#f`
|`#t`

|Keyword
|`#:` prefix
|`#:export`
|===

=== Composite Types

[cols="1,2,2"]
|===
|Type |Syntax |Example

|List
|Parenthesized elements
|`(a b c)`

|Quoted List
|Apostrophe prefix
|`'(a b c)`

|Dotted Pair
|Elements with dot
|`(key . value)`

|Association List
|List of dotted pairs
|`((a . 1) (b . 2))`
|===

=== Type Coercion

Implementations SHOULD:

* Accept both `#t`/`#f` and `#true`/`#false` for booleans
* Accept both integers and strings for numeric fields where sensible
* Normalize multi-line strings by collapsing internal whitespace


== Parsing Requirements

=== Conformance Levels

Full Conformance::
  Parser MUST handle all constructs defined in this specification.

Basic Conformance::
  Parser MUST handle core sections and MAY ignore extensions.

=== Error Handling

Implementations MUST:

* Report syntax errors with line and column numbers
* Report unknown required fields in core sections
* Silently ignore unknown optional fields for forward compatibility

Implementations SHOULD:

* Validate ADR status values
* Validate date formats
* Warn about deprecated constructs

=== Character Encoding

META files MUST be encoded in UTF-8. Implementations MUST reject files
with invalid UTF-8 sequences.

=== Line Endings

Implementations MUST accept LF (`\n`) and CRLF (`\r\n`) line endings.
Implementations SHOULD normalize to LF when writing.


== Processing Model

=== Reading META Files

1. Read file as UTF-8 text
2. Parse module declaration
3. Parse section definitions
4. Validate core section schemas
5. Return structured data

=== Merging META Files

For projects with multiple META files (e.g., per-module):

1. Merge ADR lists by ID (later files override)
2. Merge practice categories (later files override)
3. Append rationale entries (no override)

=== Tooling Integration

==== Linters

Linters SHOULD check:

* ADR IDs are sequential
* ADR dates are chronological
* Status transitions are valid (e.g., can't go from `deprecated` to `proposed`)
* Referenced ADRs exist

==== Generators

Generators MAY:

* Create Markdown documentation from META files
* Generate ADR templates
* Create changelogs from ADR histories


== Security Considerations

=== Code Execution

META files MUST NOT be executed as Scheme code. Implementations MUST:

* Parse META files as data only
* Not evaluate arbitrary expressions
* Not expand macros

=== Input Validation

When META data influences system behavior:

* Validate all paths against allowlists
* Sanitize command-line arguments
* Treat all strings as untrusted input

=== Information Disclosure

META files may contain:

* Internal architecture details
* Tool versions (potentially exploitable)
* Team member names

Consider:

* Excluding META files from public repositories if sensitive
* Redacting specific fields for public documentation


== IANA Considerations

=== Media Type Registration

This document requests registration of the media type `application/meta+scheme`.

See the separate IANA Media Type Registration document for the complete
registration template.

=== File Extension

The conventional file extension is `.scm`, specifically `META.scm` for the
primary project metadata file.


== References

=== Normative References

[bibliography]
* [[[RFC2119]]] Bradner, S., "Key words for use in RFCs to Indicate Requirement
  Levels", BCP 14, RFC 2119, March 1997.
* [[[RFC5234]]] Crocker, D. and P. Overell, "Augmented BNF for Syntax
  Specifications: ABNF", RFC 5234, January 2008.
* [[[RFC7405]]] Kyzivat, P., "Case-Sensitive String Support in ABNF",
  RFC 7405, December 2014.
* [[[R7RS]]] Shinn, A., Cowan, J., and A. Gleckler, "Revised^7 Report on the
  Algorithmic Language Scheme", 2013.

=== Informative References

[bibliography]
* [[[MADR]]] Kopp, O., "Markdown Any Decision Records",
  https://adr.github.io/madr/
* [[[SEMVER]]] Preston-Werner, T., "Semantic Versioning 2.0.0",
  https://semver.org/
* [[[SPDX]]] Linux Foundation, "SPDX Specification",
  https://spdx.dev/specifications/


== Appendix A: Complete Example

[source,scheme]
----
;; SPDX-License-Identifier: PMPL-1.0-or-later
;; SPDX-FileCopyrightText: 2025 Example Corp

;;; META.scm — Architecture Decisions and Development Practices
;;; example-api

(define-module (example-api meta)
  #:export (architecture-decisions
            development-practices
            design-rationale))

;;; Architecture Decisions Record (ADR)

(define architecture-decisions
  '((adr-001
     (title . "Use Rust for Core Services")
     (status . "accepted")
     (date . "2025-01-01")
     (context . "Need high performance with memory safety guarantees")
     (decision . "Implement core services in Rust")
     (consequences . ("Memory safety without GC"
                      "Steep learning curve"
                      "Excellent performance")))

    (adr-002
     (title . "gRPC for Internal Communication")
     (status . "accepted")
     (date . "2025-01-15")
     (context . "Need efficient binary protocol for service communication")
     (decision . "Use gRPC with Protocol Buffers")
     (consequences . ("Type-safe contracts"
                      "Efficient serialization"
                      "HTTP/2 required")))))

;;; Development Practices

(define development-practices
  '((code-style
     (formatter . "rustfmt")
     (linter . "clippy")
     (type-system . "Rust (strict)"))

    (testing
     (framework . "cargo test")
     (coverage-minimum . 80)
     (property-testing . "proptest for core algorithms"))

    (versioning
     (scheme . "Semantic Versioning 2.0.0")
     (changelog . "Keep a Changelog format"))))

;;; Design Rationale

(define design-rationale
  '((why-rust
     "Rust provides memory safety guarantees without garbage collection
      overhead. For latency-sensitive services, this eliminates GC pauses
      while preventing entire classes of security vulnerabilities.")

    (why-grpc
     "gRPC with protobuf provides strongly-typed contracts, efficient
      binary serialization, and built-in support for streaming. The
      protobuf schema serves as living documentation.")))
----


== Appendix B: JSON Binding

For environments without Scheme support, META data MAY be represented in JSON.

[source,json]
----
{
  "module": "example-api/meta",
  "architecture-decisions": [
    {
      "id": "adr-001",
      "title": "Use Rust for Core Services",
      "status": "accepted",
      "date": "2025-01-01",
      "context": "Need high performance with memory safety guarantees",
      "decision": "Implement core services in Rust",
      "consequences": [
        "Memory safety without GC",
        "Steep learning curve",
        "Excellent performance"
      ]
    }
  ],
  "development-practices": {
    "code-style": {
      "formatter": "rustfmt",
      "linter": "clippy",
      "type-system": "Rust (strict)"
    }
  },
  "design-rationale": {
    "why-rust": "Rust provides memory safety guarantees..."
  }
}
----


== Appendix C: Revision History

[cols="1,1,3"]
|===
|Version |Date |Changes

|1.0.0-draft.1
|2025-12
|Initial draft specification
|===


== Authors' Addresses

Jonathan D.A. Jewell +
Email: [See repository] +
GitHub: https://github.com/hyperpolymath
