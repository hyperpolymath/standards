; ============================================================
; .scm Format Family - Shared S-Expression Grammar
; ============================================================
;
; SPDX-License-Identifier: MIT
; Copyright (c) 2025 Jonathan D.A. Jewell
;
; This grammar defines the shared S-expression primitives used by
; all formats in the .scm family (META.scm, STATE.scm, etc.).
;
; Reference: RFC 5234 (ABNF), RFC 7405 (Case-Sensitive Strings)
;
; Formats using this grammar:
;   - META.scm  (application/meta+scheme)
;   - STATE.scm (application/state+scheme)
;
; ============================================================


; ------------------------------------------------------------
; Module Declaration (Shared Pattern)
; ------------------------------------------------------------

module-declaration  = "(" "define-module" WSP module-path
                      *module-directive ")"

module-path         = "(" 1*module-segment ")"
module-segment      = symbol

module-directive    = export-directive / use-directive / other-directive
export-directive    = "#:export" WSP "(" *symbol ")"
use-directive       = "#:use-module" WSP module-path
other-directive     = keyword WSP s-expression


; ------------------------------------------------------------
; Section Definition (Shared Pattern)
; ------------------------------------------------------------

section-definition  = "(" "define" WSP symbol WSP s-expression ")"


; ------------------------------------------------------------
; S-Expression Core
; ------------------------------------------------------------

s-expression        = atom / list / quoted-expression / quasi-expression

atom                = symbol / string / number / boolean / keyword

list                = "(" *list-element ")"
list-element        = s-expression / dotted-tail
dotted-tail         = "." WSP s-expression

quoted-expression   = "'" s-expression           ; (quote expr)
quasi-expression    = "`" s-expression           ; (quasiquote expr)
unquote-expression  = "," s-expression           ; (unquote expr)
unquote-splicing    = ",@" s-expression          ; (unquote-splicing expr)


; ------------------------------------------------------------
; Symbols
; ------------------------------------------------------------

symbol              = symbol-initial *symbol-subsequent
                    / peculiar-symbol

symbol-initial      = ALPHA / special-initial
symbol-subsequent   = symbol-initial / DIGIT / special-subsequent

special-initial     = "!" / "$" / "%" / "&" / "*" / "/" / ":"
                    / "<" / "=" / ">" / "?" / "^" / "_" / "~"

special-subsequent  = "+" / "-" / "." / "@"

; Symbols that start with + or - (must not be confused with numbers)
peculiar-symbol     = "+" / "-" / "..."
                    / ( ("+" / "-") symbol-subsequent *symbol-subsequent )


; ------------------------------------------------------------
; Keywords (Scheme #:keyword syntax)
; ------------------------------------------------------------

keyword             = "#:" symbol


; ------------------------------------------------------------
; Strings
; ------------------------------------------------------------

string              = DQUOTE *string-element DQUOTE

string-element      = string-char / escape-sequence / string-continuation

; Printable ASCII except " and \
string-char         = %x20-21 / %x23-5B / %x5D-7E
                    / UTF8-non-ascii

escape-sequence     = "\" escape-char
escape-char         = DQUOTE              ; \"  quotation mark
                    / "\"                 ; \\  reverse solidus
                    / "/"                 ; \/  solidus (optional)
                    / "b"                 ; \b  backspace
                    / "f"                 ; \f  form feed
                    / "n"                 ; \n  newline
                    / "r"                 ; \r  carriage return
                    / "t"                 ; \t  horizontal tab
                    / unicode-escape

unicode-escape      = "u" 4HEXDIG         ; \uXXXX
                    / "U" 8HEXDIG         ; \UXXXXXXXX (extended)

; Multi-line string continuation
string-continuation = "\" *WSP line-ending *WSP

; UTF-8 multi-byte sequences
UTF8-non-ascii      = UTF8-2 / UTF8-3 / UTF8-4
UTF8-2              = %xC2-DF UTF8-tail
UTF8-3              = %xE0 %xA0-BF UTF8-tail
                    / %xE1-EC 2UTF8-tail
                    / %xED %x80-9F UTF8-tail
                    / %xEE-EF 2UTF8-tail
UTF8-4              = %xF0 %x90-BF 2UTF8-tail
                    / %xF1-F3 3UTF8-tail
                    / %xF4 %x80-8F 2UTF8-tail
UTF8-tail           = %x80-BF


; ------------------------------------------------------------
; Numbers
; ------------------------------------------------------------

number              = [exactness] [radix] numeric-value
                    / [radix] [exactness] numeric-value

exactness           = "#e" / "#E"         ; exact
                    / "#i" / "#I"         ; inexact

radix               = "#b" / "#B"         ; binary
                    / "#o" / "#O"         ; octal
                    / "#d" / "#D"         ; decimal (default)
                    / "#x" / "#X"         ; hexadecimal

numeric-value       = integer / decimal / rational / complex-num

integer             = [sign] 1*DIGIT
decimal             = [sign] decimal-body [exponent]
decimal-body        = 1*DIGIT "." *DIGIT  ; 123. or 123.456
                    / "." 1*DIGIT         ; .456
                    / 1*DIGIT             ; 123 (with exponent)

exponent            = exponent-marker [sign] 1*DIGIT
exponent-marker     = "e" / "E" / "s" / "S" / "f" / "F"
                    / "d" / "D" / "l" / "L"

rational            = integer "/" positive-integer
positive-integer    = %x31-39 *DIGIT      ; 1-9 followed by digits

complex-num         = real-part [imaginary-part]
                    / imaginary-part
real-part           = [sign] ( decimal / integer )
imaginary-part      = [sign] ( decimal / integer ) "i"

sign                = "+" / "-"


; ------------------------------------------------------------
; Booleans
; ------------------------------------------------------------

boolean             = "#t" / "#f"         ; Short form
                    / "#true" / "#false"  ; Long form (R7RS)
                    / "#T" / "#F"         ; Case variants


; ------------------------------------------------------------
; Special Constants
; ------------------------------------------------------------

; Void / undefined
void                = "#<void>" / "#<unspecified>"

; Empty list
empty-list          = "()" / "'()"


; ------------------------------------------------------------
; Comments
; ------------------------------------------------------------

comment             = line-comment / block-comment / doc-comment / datum-comment

; Single line comment
line-comment        = ";" *line-char line-ending
line-char           = %x00-09 / %x0B-0C / %x0E-7F / UTF8-non-ascii

; Block comment (SRFI-30 style, nestable)
block-comment       = "#|" block-content "|#"
block-content       = *( block-char / block-comment )  ; Allows nesting
block-char          = %x00-7F / UTF8-non-ascii         ; Any character

; Documentation comment (by convention: triple semicolon)
doc-comment         = ";;;" *line-char line-ending

; Datum comment (SRFI-62 style, comments out next datum)
datum-comment       = "#;" WSP s-expression


; ------------------------------------------------------------
; Whitespace and Line Endings
; ------------------------------------------------------------

WSP                 = 1*( SP / HTAB / line-ending / comment )

SP                  = %x20                ; Space
HTAB                = %x09                ; Horizontal tab

line-ending         = CRLF / LF / CR
CRLF                = %x0D %x0A           ; Carriage return + line feed
LF                  = %x0A                ; Line feed
CR                  = %x0D                ; Carriage return (alone)


; ------------------------------------------------------------
; Association Lists (Common Pattern)
; ------------------------------------------------------------

; Association list: list of key-value pairs
alist               = "(" *alist-entry ")"
                    / quoted-alist

quoted-alist        = "'" "(" *alist-entry ")"

alist-entry         = "(" alist-key "." WSP alist-value ")"
                    / "(" alist-key WSP alist-value ")"     ; Without dot

alist-key           = symbol / keyword / string
alist-value         = s-expression


; ------------------------------------------------------------
; Date and Time (ISO 8601)
; ------------------------------------------------------------

; Full ISO 8601 date-time
datetime            = date ["T" time [timezone]]

date                = year "-" month "-" day
year                = 4DIGIT
month               = ("0" %x31-39) / ("1" %x30-32)     ; 01-12
day                 = ("0" %x31-39)                      ; 01-09
                    / (%x31-32 DIGIT)                    ; 10-29
                    / ("3" %x30-31)                      ; 30-31

time                = hour ":" minute [":" second [fraction]]
hour                = (%x30-31 DIGIT) / ("2" %x30-33)   ; 00-23
minute              = %x30-35 DIGIT                      ; 00-59
second              = %x30-35 DIGIT                      ; 00-59
fraction            = "." 1*DIGIT

timezone            = "Z"                                ; UTC
                    / ("+" / "-") hour ":" minute        ; Offset


; ------------------------------------------------------------
; Semantic Version (SemVer 2.0.0)
; ------------------------------------------------------------

semver              = major "." minor "." patch
                      ["-" prerelease] ["+" build-metadata]

major               = numeric-id
minor               = numeric-id
patch               = numeric-id

prerelease          = prerelease-id *("." prerelease-id)
prerelease-id       = alphanumeric-id / numeric-id

build-metadata      = build-id *("." build-id)
build-id            = alphanumeric-id / 1*DIGIT

numeric-id          = "0" / (%x31-39 *DIGIT)            ; No leading zeros
alphanumeric-id     = 1*( ALPHA / DIGIT / "-" )


; ------------------------------------------------------------
; URI Reference (RFC 3986 simplified)
; ------------------------------------------------------------

uri                 = scheme ":" hier-part ["?" query] ["#" fragment]

scheme              = ALPHA *( ALPHA / DIGIT / "+" / "-" / "." )

hier-part           = "//" authority path-abempty
                    / path-absolute
                    / path-rootless
                    / path-empty

authority           = [userinfo "@"] host [":" port]
userinfo            = *( unreserved / pct-encoded / sub-delims / ":" )
host                = ip-literal / ipv4address / reg-name
port                = *DIGIT

reg-name            = *( unreserved / pct-encoded / sub-delims )

path-abempty        = *( "/" segment )
path-absolute       = "/" [ segment-nz *( "/" segment ) ]
path-rootless       = segment-nz *( "/" segment )
path-empty          = ""

segment             = *pchar
segment-nz          = 1*pchar
pchar               = unreserved / pct-encoded / sub-delims / ":" / "@"

query               = *( pchar / "/" / "?" )
fragment            = *( pchar / "/" / "?" )

unreserved          = ALPHA / DIGIT / "-" / "." / "_" / "~"
pct-encoded         = "%" HEXDIG HEXDIG
sub-delims          = "!" / "$" / "&" / "'" / "(" / ")"
                    / "*" / "+" / "," / ";" / "="

; IP addresses (simplified)
ip-literal          = "[" ( ipv6address / ipvfuture ) "]"
ipv4address         = dec-octet "." dec-octet "." dec-octet "." dec-octet
dec-octet           = DIGIT / (%x31-39 DIGIT) / ("1" 2DIGIT)
                    / ("2" %x30-34 DIGIT) / ("25" %x30-35)
ipv6address         = 6( h16 ":" ) ls32
                    ; ... (simplified, see RFC 3986 for full grammar)
ipvfuture           = "v" 1*HEXDIG "." 1*( unreserved / sub-delims / ":" )
h16                 = 1*4HEXDIG
ls32                = ( h16 ":" h16 ) / ipv4address


; ------------------------------------------------------------
; SPDX License Expression (Simplified)
; ------------------------------------------------------------

spdx-expression     = spdx-term *( WSP spdx-operator WSP spdx-term )

spdx-term           = spdx-license-id
                    / spdx-license-id "+"               ; Or later
                    / "(" spdx-expression ")"

spdx-license-id     = 1*( ALPHA / DIGIT / "-" / "." )

spdx-operator       = "AND" / "OR" / "WITH"


; ------------------------------------------------------------
; File Path (Platform-Neutral)
; ------------------------------------------------------------

file-path           = absolute-path / relative-path

absolute-path       = "/" *path-component
                    / windows-absolute                   ; C:\...

relative-path       = path-component *( "/" path-component )
                    / "." ["/" relative-path]            ; ./...
                    / ".." ["/" relative-path]           ; ../...

path-component      = 1*path-char
path-char           = ALPHA / DIGIT / "-" / "_" / "."

windows-absolute    = ALPHA ":" "\" *windows-component
windows-component   = path-component *( "\" path-component )


; ------------------------------------------------------------
; Core ABNF Rules (RFC 5234)
; ------------------------------------------------------------

ALPHA               = %x41-5A / %x61-7A  ; A-Z / a-z
DIGIT               = %x30-39            ; 0-9
HEXDIG              = DIGIT / "A" / "B" / "C" / "D" / "E" / "F"
                    / "a" / "b" / "c" / "d" / "e" / "f"
DQUOTE              = %x22               ; "
VCHAR               = %x21-7E            ; Visible characters


; ============================================================
; END OF SHARED GRAMMAR
; ============================================================
