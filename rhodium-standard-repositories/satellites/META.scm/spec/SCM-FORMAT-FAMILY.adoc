= .scm Format Family Specification
:doctype: book
:toc: left
:toclevels: 4
:sectnums:
:source-highlighter: highlight.js
:icons: font

[.text-center]
*Unified Specification for Scheme-based Data Formats* +
*Version 1.0.0-draft.1* +
*December 2025*

== Abstract

This document specifies the .scm Format Family, a suite of interoperable
Scheme S-expression-based data formats for software engineering workflows.
The family currently comprises two formats:

* **META.scm** — Machine-readable Engineering and Technical Architecture
* **STATE.scm** — Stateful Context Tracking Engine for AI Conversations

Both formats share common syntax primitives, design principles, and standards
track infrastructure while serving complementary purposes in the software
development lifecycle.

== Status of This Memo

This document specifies an experimental protocol for the Internet community.
Distribution of this memo is unlimited.

== Copyright Notice

Copyright (c) 2025 Jonathan D.A. Jewell. MIT License.


== Introduction

=== The .scm Format Family

The .scm Format Family addresses the need for human-readable, machine-parseable
data formats in modern software engineering:

[cols="1,2,2"]
|===
|Format |Purpose |Primary Use Case

|META.scm
|Project governance and architecture documentation
|ADRs, development practices, design rationale

|STATE.scm
|AI conversation checkpoint and restore
|Session persistence, context continuity, workflow state
|===

=== Design Philosophy

All .scm formats share these core principles:

Declarative Data::
  Pure data structures, not executable code

Human Readable::
  S-expression syntax readable without special tooling

Machine Parseable::
  Formal grammar enables automated processing

Interoperable::
  Shared primitives enable cross-format tooling

Extensible::
  Custom sections without breaking compatibility

VCS Friendly::
  Text-based format works with version control

=== Relationship Between Formats

----
                    ┌─────────────────────────────────────┐
                    │     .scm Format Family              │
                    │   (Shared S-expression Syntax)      │
                    └─────────────────────────────────────┘
                                    │
                    ┌───────────────┴───────────────┐
                    │                               │
            ┌───────▼───────┐               ┌──────▼──────┐
            │   META.scm    │               │  STATE.scm  │
            │               │               │             │
            │ • ADRs        │               │ • Sessions  │
            │ • Practices   │◄─────────────►│ • Context   │
            │ • Rationale   │  References   │ • Progress  │
            └───────────────┘               └─────────────┘
                    │                               │
                    ▼                               ▼
            Project Metadata              AI Workflow State
----

STATE.scm files MAY reference META.scm for project context:

[source,scheme]
----
;; In STATE.scm
(projects
  '((name . "my-project")
    (meta-ref . "META.scm")  ; Reference to project's META.scm
    (active-adrs . (adr-001 adr-003))))  ; Currently relevant decisions
----


== Shared Syntax Foundation

=== Common ABNF Primitives

All .scm formats share these syntax primitives (defined in `shared/s-expression.abnf`):

[source,abnf]
----
; S-Expression Core
s-expression    = atom / list / quoted-expression
atom            = symbol / string / number / boolean / keyword
list            = "(" *s-expression ")"
quoted-expression = "'" s-expression

; Symbols
symbol          = symbol-initial *symbol-subsequent
symbol-initial  = ALPHA / special-initial
symbol-subsequent = symbol-initial / DIGIT / special-subsequent

; Strings (with escape sequences)
string          = DQUOTE *string-char DQUOTE
string-char     = %x20-21 / %x23-5B / %x5D-7E / escape-sequence

; Comments
comment         = line-comment / block-comment / doc-comment
line-comment    = ";" *VCHAR (CRLF / LF)
doc-comment     = ";;;" *VCHAR (CRLF / LF)
----

=== Common Data Types

[cols="1,2,2"]
|===
|Type |Both Formats |Usage

|ISO 8601 Date
|`"2025-01-15"`
|Timestamps, decisions dates

|Semantic Version
|`"1.0.0"`, `"2.1.0-beta.1"`
|Format versions, project versions

|Symbol Identifiers
|`adr-001`, `session-abc123`
|Unique identifiers

|Association Lists
|`((key . value) ...)`
|Structured key-value data

|Status Enums
|Predefined symbol sets
|State machines, workflows
|===

=== Module Declaration Pattern

Both formats use Guile/R7RS module syntax:

[source,scheme]
----
(define-module (project-name format-type)
  #:export (section1 section2 ...))
----


== META.scm Specification Summary

=== Purpose

Document project governance, architecture decisions, and development practices
in machine-readable format.

=== Core Sections

[cols="1,3"]
|===
|Section |Content

|`architecture-decisions`
|ADRs with status lifecycle (proposed → accepted → deprecated/superseded)

|`development-practices`
|Code style, security, testing, versioning policies

|`design-rationale`
|Narrative explanations linking to ADRs
|===

=== Example

[source,scheme]
----
(define-module (my-project meta)
  #:export (architecture-decisions development-practices design-rationale))

(define architecture-decisions
  '((adr-001
     (title . "Event Sourcing for Orders")
     (status . "accepted")
     (date . "2025-01-15")
     (context . "Need complete audit trail")
     (decision . "Use event sourcing pattern")
     (consequences . ("Immutable history" "Temporal queries")))))
----

=== Full Specification

See link:META-FORMAT-SPEC.adoc[META-FORMAT-SPEC.adoc] for complete details.


== STATE.scm Specification Summary

=== Purpose

Checkpoint AI conversation context for session persistence and workflow
continuity across interactions.

=== Core Sections

[cols="1,3"]
|===
|Section |Content

|`metadata`
|Format version, creation/modification timestamps, session lineage

|`user`
|User identity, preferences, communication style

|`session`
|Current session ID, status, goals, conversation summary

|`focus`
|Active file, function, task context

|`projects`
|Project state, dependencies, progress tracking

|`environment`
|Runtime context, tools, capabilities

|`memory`
|Key learnings, decisions, discoveries from conversation
|===

=== Example

[source,scheme]
----
(define-module (ai-session state)
  #:export (metadata session focus projects memory))

(define metadata
  '((version . "2.0.0")
    (created . "2025-01-15T10:30:00Z")
    (modified . "2025-01-15T14:45:00Z")))

(define session
  '((id . "session-abc123")
    (status . "active")
    (goals . ("Implement user authentication" "Write tests"))))

(define focus
  '((current-file . "src/auth/handler.ts")
    (current-task . "Implementing OAuth flow")))
----

=== Full Specification

See STATE-FORMAT-SPEC.adoc (in state.scm repository) for complete details.


== Cross-Format Integration

=== META References in STATE

STATE.scm files can reference META.scm for project context:

[source,scheme]
----
;; STATE.scm referencing META.scm
(define projects
  '((name . "enterprise-api")
    (path . "/home/user/enterprise-api")
    (meta . ((ref . "META.scm")
             (active-adrs . (adr-001 adr-003 adr-007))
             (relevant-practices . (security testing))))
    (status . "in-progress")))
----

=== Shared Tooling Benefits

Tools built for the .scm family can:

1. **Parse both formats** with shared S-expression parser
2. **Cross-reference** STATE sessions with META architecture decisions
3. **Generate documentation** combining project governance and AI session history
4. **Validate consistency** between STATE project references and META definitions

=== Integration Scenarios

==== Scenario 1: AI-Assisted Architecture Review

1. AI session loads STATE.scm with project context
2. STATE references META.scm's `architecture-decisions`
3. AI can query relevant ADRs while making implementation decisions
4. Session memory records which ADRs influenced the work

==== Scenario 2: Development Practice Enforcement

1. STATE.scm tracks current task context
2. META.scm defines testing and security requirements
3. Tooling ensures AI suggestions comply with documented practices
4. Violations are flagged against specific practice definitions

==== Scenario 3: Project Onboarding

1. New developer starts AI-assisted session
2. STATE.scm initializes with META.scm reference
3. AI has immediate access to:
   - Architecture decisions and rationale
   - Development practices and tooling
   - Design philosophy and constraints


== Unified Standards Track

=== Single Submission Strategy

The .scm Format Family will be submitted as a cohesive specification:

----
Year 1                    Year 2                    Year 3+
├──────────────────────────┼──────────────────────────┼───────
│                          │                          │
│ Phase 1: Community Spec  │ Phase 3: IETF I-D        │
│ ▓▓▓▓▓▓▓▓▓▓               │ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ │
│ • META.scm spec          │ • Combined I-D           │
│ • STATE.scm spec         │ • Single RFC or          │
│ • Shared primitives      │   RFC series             │
│                          │                          │
│ Phase 2: IANA            │ Phase 4: Ecosystem       │ ISO?
│ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓         │ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ │ ▓▓▓▓
│ • application/meta+scheme│ • SPDX integration       │
│ • application/state+scheme│ • Tool ecosystem        │
└──────────────────────────┴──────────────────────────┴───────
----

=== Media Type Registrations

[cols="1,2"]
|===
|Media Type |Format

|`application/meta+scheme`
|META.scm files

|`application/state+scheme`
|STATE.scm files

|`application/scm+scheme`
|Generic .scm family (future)
|===

=== RFC Structure Options

**Option A: Single RFC**
- Combined specification with shared primitives
- Sections for each format
- Appendices for format-specific details

**Option B: RFC Series**
- RFC-SCM-CORE: Shared S-expression primitives
- RFC-SCM-META: META.scm specification
- RFC-SCM-STATE: STATE.scm specification

Recommendation: **Option B** for modularity and independent evolution.


== Extensibility

=== Adding New Formats

The .scm family is designed for extension. New formats MUST:

1. Use shared S-expression syntax from `shared/s-expression.abnf`
2. Follow module declaration pattern
3. Define format-specific sections
4. Register media type in `application/*+scheme` tree
5. Document integration points with existing formats

=== Candidate Future Formats

[cols="1,3"]
|===
|Potential Format |Purpose

|CONFIG.scm
|Application configuration with environment overrides

|DEPS.scm
|Dependency declaration with resolution metadata

|FLOW.scm
|Workflow definitions for automation pipelines

|TEST.scm
|Test specifications and coverage requirements
|===


== Security Considerations

=== Code Execution Prevention

All .scm formats MUST be parsed as data only:

* Implementations MUST NOT evaluate S-expressions as code
* Implementations MUST NOT expand macros
* Implementations MUST NOT execute procedures

=== Cross-Format Security

When STATE.scm references META.scm:

* Path references MUST be validated against allowlists
* Remote references (URLs) SHOULD be restricted or disabled
* Circular references MUST be detected and rejected

=== Information Sensitivity

[cols="1,1,2"]
|===
|Format |Sensitivity |Considerations

|META.scm
|Medium
|Architecture details, team practices

|STATE.scm
|High
|Conversation content, user context, session history
|===

Implementations SHOULD provide separate access controls for each format.


== IANA Considerations

=== Media Type Family

Request registration of the following media types:

1. `application/meta+scheme` — META.scm format
2. `application/state+scheme` — STATE.scm format

Both use the `+scheme` suffix to indicate Scheme S-expression syntax.

=== Future Registrations

Additional .scm family formats will follow the pattern:
`application/{format-name}+scheme`


== References

=== Normative References

* RFC 2119 — Key words for RFCs
* RFC 5234 — ABNF
* RFC 7405 — Case-Sensitive String Support in ABNF
* R7RS — Revised^7 Report on the Algorithmic Language Scheme

=== Informative References

* MADR — Markdown Any Decision Records
* SPDX — Software Package Data Exchange
* SemVer 2.0.0 — Semantic Versioning


== Appendix A: Format Comparison

[cols="1,2,2"]
|===
|Aspect |META.scm |STATE.scm

|*Purpose*
|Project documentation
|Session persistence

|*Lifetime*
|Long-lived (project lifetime)
|Short-lived (session/workflow)

|*Updates*
|Infrequent (decisions, policy changes)
|Frequent (every interaction)

|*Primary User*
|Developers, architects
|AI systems, automation

|*Size*
|Small-medium (KB)
|Medium-large (KB-MB)

|*Versioning*
|Git-tracked, reviewed
|Auto-generated, rotated
|===


== Appendix B: Shared Grammar Reference

The complete shared ABNF grammar is in `shared/s-expression.abnf`.

Key shared constructs:

* S-expression primitives (atoms, lists, quotes)
* Comment syntax (line, block, documentation)
* String escaping and multi-line support
* Number formats (integer, decimal, rational)
* Boolean representations (#t/#f, #true/#false)
* Date/time formats (ISO 8601)
* Semantic version strings


== Appendix C: Implementation Guidance

=== Parser Architecture

Recommended parser structure:

----
┌─────────────────────────────────────────────┐
│              .scm Parser Core               │
│         (Shared S-expression parsing)       │
└─────────────────────────────────────────────┘
                      │
        ┌─────────────┼─────────────┐
        │             │             │
        ▼             ▼             ▼
┌───────────┐  ┌───────────┐  ┌───────────┐
│   META    │  │   STATE   │  │  Future   │
│ Validator │  │ Validator │  │ Validator │
└───────────┘  └───────────┘  └───────────┘
----

=== Reference Implementations

Planned reference implementations:

* **TypeScript/Deno** — Primary reference
* **Rust** — Performance-critical applications
* **Python** — Data science and scripting
* **Go** — Cloud-native tooling


== Document History

[cols="1,1,3"]
|===
|Version |Date |Changes

|1.0.0-draft.1
|2025-12
|Initial unified specification
|===


== Authors' Addresses

Jonathan D.A. Jewell +
GitHub: https://github.com/hyperpolymath
