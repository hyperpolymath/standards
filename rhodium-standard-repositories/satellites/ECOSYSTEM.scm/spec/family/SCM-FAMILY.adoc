= The SCM Format Family
:author: Jonathan D.A. Jewell
:revdate: 2025-12-15
:toc:
:toclevels: 3
:sectnums:
:icons: font

== Overview

The **SCM Format Family** is a collection of declarative S-expression formats designed to capture different dimensions of software development context. Each format addresses a specific domain while sharing common syntax, conventions, and tooling infrastructure.

[source]
----
┌─────────────────────────────────────────────────────────────────┐
│                     SCM Format Family                           │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ┌─────────────────┐    ┌─────────────────┐    ┌─────────────┐ │
│  │   STATE.scm     │    │  ECOSYSTEM.scm  │    │  Future...  │ │
│  │                 │    │                 │    │             │ │
│  │ Session State   │    │ Project Context │    │ BUILD.scm?  │ │
│  │ Conversation    │    │ Relationships   │    │ CONFIG.scm? │ │
│  │ Progress        │    │ Boundaries      │    │             │ │
│  └────────┬────────┘    └────────┬────────┘    └──────┬──────┘ │
│           │                      │                     │        │
│           └──────────────────────┼─────────────────────┘        │
│                                  │                              │
│                    ┌─────────────┴─────────────┐                │
│                    │    Shared Primitives      │                │
│                    │    Common ABNF Core       │                │
│                    │    Unified Media Types    │                │
│                    └───────────────────────────┘                │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
----

== Family Members

=== STATE.scm

**Domain:** AI Conversation Session State

**Purpose:** Checkpoint and restore AI conversation context across sessions. Preserves user preferences, project progress, decision queues, and session history.

**Key Forms:**
[source,scheme]
----
(state
  (metadata ...)      ; Version, timestamps, generator
  (user ...)          ; Profile, preferences, values
  (session ...)       ; Conversation ID, tokens, messages
  (focus ...)         ; Current project, phase, deadlines
  (projects ...)      ; Full project catalogue with status
  (history ...)       ; Snapshots for velocity tracking
  (next-actions ...)) ; Prioritised task queue
----

**Repository:** https://github.com/hyperpolymath/state.scm

**Media Type:** `application/vnd.state+scm`

=== ECOSYSTEM.scm

**Domain:** Project Ecosystem Context

**Purpose:** Describe software project relationships, boundaries, and position within the broader ecosystem.

**Key Forms:**
[source,scheme]
----
(ecosystem
  (version ...)              ; Document version
  (name ...)                 ; Project name
  (type ...)                 ; Category (library, app, etc.)
  (purpose ...)              ; Concise description
  (position-in-ecosystem ...)
  (related-projects ...)     ; Typed relationships
  (what-this-is ...)
  (what-this-is-not ...))
----

**Repository:** https://github.com/hyperpolymath/ECOSYSTEM.scm

**Media Type:** `application/vnd.ecosystem+scm`

=== Future Members

Potential future family members under consideration:

[cols="2,3,3"]
|===
| Format | Domain | Purpose

| `BUILD.scm`
| Build Configuration
| Declarative build recipes (alternative to justfile)

| `CONFIG.scm`
| Application Config
| Runtime configuration with schema validation

| `DEPLOY.scm`
| Deployment Context
| Environment, secrets references, infrastructure

| `REVIEW.scm`
| Code Review State
| Review comments, decisions, approval workflow
|===

== Design Principles

The SCM family shares these design principles:

=== 1. Human Readability First

S-expressions were chosen because they are:
- Self-explanatory without documentation
- Editable in any text editor
- Naturally hierarchical
- Comment-friendly

=== 2. Version Control Friendly

All formats:
- Produce meaningful diffs
- Avoid unnecessary ordering changes
- Use multiline strings for prose
- Support comments for context

=== 3. Minimal Required Fields

Each format defines only essential required fields. Rich metadata is available but optional, reducing adoption friction.

=== 4. Extensibility

All formats support vendor extensions via `x-` prefixed fields:

[source,scheme]
----
(ecosystem
  (name "my-project")
  (x-acme-internal-id "PRJ-12345")  ; Vendor extension
  (x-exp-maintainers ("alice")))     ; Experimental
----

=== 5. Tooling Compatibility

Standard S-expression parsers can read all family formats. No custom syntax extensions are required.

== Shared Infrastructure

=== Common ABNF Core

All SCM formats share a common ABNF foundation:

[source,abnf]
----
; See spec/family/scm-core.abnf for full grammar

; Shared primitives
string = DQUOTE *string-char DQUOTE
identifier = ALPHA *( ALPHA / DIGIT / "-" / "_" )
url-string = string  ; Valid URI per RFC 3986
semver = string      ; Semantic versioning 2.0.0

; Shared constructs
comment = ";" *VCHAR ( LF / CR / CRLF )
extension-field = "(" "x-" identifier 1*WSP sexp ")"
----

=== Unified Media Type Structure

All family media types follow the pattern:

`application/vnd.<format>+scm`

[cols="2,3"]
|===
| Format | Media Type

| STATE.scm
| `application/vnd.state+scm`

| ECOSYSTEM.scm
| `application/vnd.ecosystem+scm`

| Future
| `application/vnd.<name>+scm`
|===

=== File Naming Conventions

[cols="2,2,3"]
|===
| Pattern | Example | Usage

| `<FORMAT>.scm`
| `ECOSYSTEM.scm`
| Repository root (canonical)

| `*.<format>.scm`
| `myproject.ecosystem.scm`
| Multiple files, subdirectories

| `*.<format>`
| `myproject.ecosystem`
| Short form (alternative)
|===

== Integration Patterns

=== Cross-Referencing

Formats can reference each other:

[source,scheme]
----
;; In STATE.scm
(state
  (metadata
    (ecosystem-ref "https://github.com/org/project/ECOSYSTEM.scm"))
  ...)

;; In ECOSYSTEM.scm
(ecosystem
  (specification
    (related-formats
      (format
        (name "STATE.scm")
        (purpose "Session state for this project")
        (location "./STATE.scm"))))
  ...)
----

=== Embedding

Smaller formats may be embedded within larger ones:

[source,scheme]
----
(state
  (metadata ...)
  (embedded-ecosystem  ; Full ECOSYSTEM.scm content
    (ecosystem
      (name "project-name")
      ...)))
----

=== Tooling Discovery

Tools can discover SCM files via:

1. **Filename:** Look for `*.scm` matching known patterns
2. **Content:** Parse and check for known root forms (`state`, `ecosystem`)
3. **Media type:** HTTP `Content-Type` header for served files

== Standards Strategy

=== Unified IETF Approach

The SCM family will pursue standardisation as a coordinated set:

1. **Individual I-Ds:** Each format has its own Internet-Draft
2. **Family Overview:** Shared document describing the family
3. **Common Registration:** Coordinated IANA media type registration

=== Timeline

[source]
----
2025 Q4: Individual format specifications complete     ✓
2026 Q1: Shared infrastructure and integration
2026 Q2: Community review and implementations
2026 Q3: IETF submission (coordinated)
2026 Q4: RFC publication target
----

=== IANA Registration Block

Request registration of the following media type family:

[cols="2,3"]
|===
| Media Type | Specification

| `application/vnd.state+scm`
| draft-jewell-state-scm

| `application/vnd.ecosystem+scm`
| draft-jewell-ecosystem-scm

| `application/vnd.scm` (reserved)
| Future family container format
|===

== Implementations

=== Reference Implementations

Recommended implementation languages:

[cols="2,2,3"]
|===
| Language | Priority | Notes

| Rust
| Primary
| Reference implementations, CLI tools

| TypeScript
| Primary
| Web tooling, VS Code extensions

| Guile Scheme
| High
| Native format, REPL integration

| Python
| Medium
| Scripting, data analysis

| Go
| Medium
| Cloud tooling, CI/CD
|===

=== Shared Parser Library

A shared parser library will provide:

[source,rust]
----
// Hypothetical API
use scm_family::{parse, Format};

let doc = parse(content)?;

match doc.format() {
    Format::State => handle_state(doc.as_state()?),
    Format::Ecosystem => handle_ecosystem(doc.as_ecosystem()?),
    Format::Unknown(name) => warn!("Unknown format: {}", name),
}
----

== Governance

=== Maintainership

* **Family Steward:** Jonathan D.A. Jewell
* **Individual Formats:** May have additional maintainers
* **Changes:** Via GitHub PRs with review

=== Versioning

Each format is versioned independently using Semantic Versioning:

* **Major:** Breaking changes to required fields or semantics
* **Minor:** New optional fields or capabilities
* **Patch:** Clarifications, typo fixes

The family itself has a coordination version for shared infrastructure.

=== Contribution

Contributions welcome via:

* https://github.com/hyperpolymath/state.scm
* https://github.com/hyperpolymath/ECOSYSTEM.scm

== Appendix: Why S-Expressions?

=== Comparison with Alternatives

[cols="2,1,1,1,1"]
|===
| Criterion | S-expr | JSON | YAML | TOML

| Human readable
| ✓✓
| ✓
| ✓✓
| ✓✓

| Comments
| ✓
| ✗
| ✓
| ✓

| Multiline strings
| ✓
| Escape
| ✓✓
| ✓

| Nesting clarity
| ✓✓
| ✓
| Indent
| ✓

| Parser simplicity
| ✓✓
| ✓
| Complex
| ✓

| Homoiconicity
| ✓✓
| ✗
| ✗
| ✗
|===

=== Homoiconicity Advantage

S-expressions represent both data and code uniformly. This enables:

* **Macro expansion:** Transform documents programmatically
* **REPL integration:** Load and query in Scheme/Lisp REPLs
* **Self-description:** Formats can describe their own grammar
